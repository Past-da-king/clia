import subprocess
from typing import Optional
import shlex # Use shlex for safer command handling

from swe_tools.__init__ import mcp

@mcp.tool(name="run_shell_command", description="This tool executes arbitrary shell commands directly on the underlying operating system's command-line interface (CLI). It is designed for comprehensive interaction with the system, allowing for the execution of system utilities (e.g., `ls`, `dir`, `cat`, `grep`, `find`), scripts (e.g., Python, Bash), version control operations (e.g., `git status`, `git diff`), file system manipulations (e.g., `mkdir`, `rm`, `cp`, `mv`), and inspection of system configurations or logs. The command is run as a subprocess, and its execution is not sandboxed, meaning it has the same permissions as the AI agent itself. The tool captures and returns the full output, including both standard output (stdout) and standard error (stderr), along with the command's exit status and numerical return code. A return code of 0 typically indicates successful execution, while any non-zero value signifies an error. The output format explicitly separates these components for clear interpretation. Users must specify the `command` string, and can optionally provide a `working_directory` (absolute path) to control the execution context; if omitted, the command runs in the AI agent's current working directory. Be aware that commands executed via this tool can have significant side effects, including modifying the file system, initiating network connections, or altering system state. Therefore, extreme caution and explicit user confirmation are paramount before executing any command that could lead to unintended consequences.")
def run_shell_command(command: str, working_directory: Optional[str] = None) -> str:
    """
    Executes a given command in a robust, non-blocking way that captures all output
    without deadlocking. Works for any command, including Python, npm, etc.

    Args:
        command: The command to execute.
        working_directory: Optional directory to run the command in.
    """
    if not command:
        return "Error: No command provided."

    try:
        # --- The Universal Solution: Popen + communicate ---
        # Popen starts the process without blocking.
        # We redirect stdout and stderr to pipes that we can read from.
        # Using shell=True allows for shell features like redirection ('>') and
        # finding commands like 'npm' or 'python' in the system's PATH.
        process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=working_directory,
        )

        # .communicate() is the key. It reads data from stdout and stderr pipes
        # simultaneously and waits for the process to terminate. This avoids the
        # deadlock scenario where the child process hangs waiting for its output
        # buffer to be read. A timeout is included as a final safeguard.
        stdout, stderr = process.communicate(timeout=60) # Increased timeout for potential installs

        return_code = process.returncode

        output = [
            f"Status: {'Success' if return_code == 0 else 'Failure'}",
            f"Return Code: {return_code}",
            "--- stdout ---",
            stdout.strip(),
            "--- stderr ---",
            stderr.strip()
        ]
        return "\n".join(output)

    except subprocess.TimeoutExpired as e:
        # If the process times out, we ensure it's terminated.
        process.kill()
        # We still try to communicate to get any output captured before the kill.
        stdout, stderr = process.communicate()
        timeout_output = [
            "Status: Failure",
            "Return Code: -1 (Terminated due to timeout)",
            f"Error: Command '{command}' timed out after 60 seconds and was terminated.",
            "--- stdout (captured before timeout) ---",
            stdout.strip() if stdout else "No stdout captured.",
            "--- stderr (captured before timeout) ---",
            stderr.strip() if stderr else "No stderr captured."
        ]
        return "\n".join(timeout_output)

    except Exception as e:
        return f"Error executing command '{command}': {e}"